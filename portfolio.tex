\documentclass[11pt]{scrartcl}
\usepackage[a4paper,margin=2.5cm]{geometry}
\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt}
\usepackage[utf8]{inputenc}
\usepackage[brazil,portuguese]{babel}
% define styles for code listings
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\lstdefinestyle{cpp}{
    language=c++,%
    basicstyle=\ttfamily\small,
    commentstyle=\color{Green},
    keywordstyle=\color{blue},
    stringstyle=\color{Orange},
    keepspaces=true,
    showstringspaces=false,
    frame=simple,%p
    breaklines=true,%p
    breakatwhitespace=true,%p
    numbers=left,%p
    tabsize=2,%p
    % numberstyle=\tiny,%p
    showspaces=false,
}
\lstdefinestyle{java}{
    language=java,%
    basicstyle=\ttfamily\small,
    commentstyle=\color{Green},
    keywordstyle=\color{blue},
    stringstyle=\color{Orange},
    keepspaces=true,
    showstringspaces=false
}
% customize pdf document properties
\usepackage[pdftex]{hyperref}
\hypersetup{%
  bookmarksopen=false,
  colorlinks=true,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=blue
}
\definecolor{bg_code_color}{RGB}{225,225,225}
\newcommand{\code}[1]{\texttt{\colorbox{bg_code_color}{#1}}}

%------------------------------------------------------------------------------%
\begin{document}

\vspace*{\fill}

\hrule
\begin{center}
\Huge
\textsc{Portfólio de Introdução à Programação Competitiva}

\medskip
\Large
Lucas Caetano Possatti\\
\large
\texttt{lucas.c.possatti@gmail.com}

\bigskip

Professores:\\
\emph{Jefferson O. Andrade}\\
\emph{Flávio S. Lamas de Souza}

\bigskip

\today
\end{center}
\hrule

\vspace*{\fill}
\thispagestyle{empty}

\newpage

\setcounter{tocdepth}{2}
\tableofcontents

\newpage


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Introdução}

\subsection{Começando: Super Fáceis}
\subsubsection{UVa 10550 - Combination Lock}
Foi codificado o cálculo do total de ângulos, exatamente como descrito
no enunciado do problema.
\lstinputlisting[style=cpp]{src/combination.cpp}

\subsection{Começando: Fáceis}
\subsubsection{UVa 11799 - Horror Dash}
Para cada caso de teste, eu construo um array com as velocidades das ``criaturas assustadoras''. E desse array, eu procuro qual é a maior velocidade. Essa deve ser a velocidade mínima do palhaço.
\lstinputlisting[style=cpp]{src/uva11799-horror-dash/horror-dash.cpp}

\subsection{Começando: Médios}
\subsubsection{UVa 573 - The Snail}
Eu fiz um loop para iterar cada dia, e o loop cálcula os valores que a lesma sobe e escorrega a cada dia, igual ao exemplo dado na descrição do problema.
\lstinputlisting[style=cpp]{src/uva00573-the-snail/snail.cpp}

\subsection{Problemas Ad Hoc}
\subsubsection{UVa 10189 - Minesweeper}
Eu li todo o campo minado para uma matriz condensada em uma array, para a qual eu tinha funções auxiliares para inserir e ler valores. Para resolver o problema em si, eu varri toda a matriz substituindo os campos vazios (`.') pela quantidade de minas (`*') ao redor. A substituição funciona da seguinte forma. Eu verifico se as coordenas adjacentes contém minas, e assim conto o número delas. Ao invés de evitar que a função leia fora das fronteiras do campo, eu fiz um pequeno truque na função que retorna o valor de uma casa (dado as coordenadas), ela retorna o caracter nulo quando uma coordenada está fora dos limites da matriz. Então, como a função que conta as minas adjacentes conta apenas as minas (`*'), ela ignora o caracter nulo, que é o caso em que uma leitura é feita fora dos limites do campo.
\lstinputlisting[style=cpp]{src/uva10189-minesweeper/main.cpp}

TBD

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Bibliotecas e Estruturas de Dados}

\subsection{Estruturas de Dados Lineares}
\subsubsection{UVa 00414 - Machined Surfaces}
Para cada caso de teste, eu li cada linha contando o número de espaços entre as peças, e armazenei o número de espaços em um vetor. Encontrei o menor dos espaços. Subtraí dos outros espaços, como se as duas peças tivessem se aproximado até encostarem. E então calculei o número de espaços que restaram entre as peças, que é a resposta.
\lstinputlisting[style=cpp]{src/uva00414-machined-surfaces/main.cpp}

\subsection{Estruturas de Dados Não Lineares}
\subsubsection{UVa 10226 - Hardwood Species}
Eu li todas todos os nomes de árvores para um mapa (\code{map<string, int> tree\_map}) que guarda o nome da árvore e o número de vezes que ela aparece naquele caso de testes. Ao mesmo tempo, contei o número de árvores na variável \code{n\_trees}. Depois, iterei sobre o mapa, imprimindo o nome da árvore e sua porcentagem (calculada por: \code{iterator->second / n\_trees}).
\lstinputlisting[style=cpp]{src/uva10226-hardwood-species/main.cpp}


\subsection{Bibliotecas Próprias: Grafos}
\subsubsection{UVa 00599 - The Forrest for the Trees}
Eu armazenei a entrada em uma lista de arestas, e uma lista de vértices. Então percorri cada aresta da lista tentando construir uma figura geral das árvores. Para isso, criei uma lista de uma lista de vértices de cada árvore. No final, eu imprimo o número de árvores que eu consegui construir. E para os ``acorns'', eu percorri a lista de vértices verificando quais vértices não pertenciam a árvore alguma.
\lstinputlisting[style=cpp]{src/uva00599-the-forrest-for-the-trees/main.cpp}

\subsection{Bibliotecas Próprias: Conjuntos Disjuntos}

\subsection{Bibliotecas Próprias: Árvores de Segmentos}

\subsection{Bibliotecas Próprias: Árvores de Fenwick}

TBD

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Paradigmas de Resolução de Problemas}

\subsection{Pesquisa Completa}
\subsubsection{UVa 00102 - Ecological Bin Packing}
Assim como sugerido pelo livro eu tentei as seis combinações possíveis de rearranjos. Criei seis diferentes funções que fazem cada um desses rearranjos. E fiz um mapa (\code{combination}) para armazenar a quantidade de movimentos necessárias para cada rearranjo. Em seguida, eu busquei \textbf{em ordem alfabética} quais tinham as menores quantidade. E imprime o menor, conforme pedido pelo problema.
\lstinputlisting[style=cpp]{src/uva00102-ecological-bin-packing/main.cpp}

\subsection{Dividir e Conquistar}
\subsubsection{UVa 10611 - Playboy Chimp}
Após ler os dados, eu percorri o vetor de macacas (\code{chimps}) na ordem crescente, procurando por aquela que tivesse maior altura, mas fosse menor que o macaco. E percorri o mesmo vetor na ordem decrescente, procurando a macaca que tivesse a menor altura, mas que fosse maior que o macaco. Fiz essas duas iterações para cada um dos diferentes valores do vetor de alturas do macaco (\code{queries}).
\lstinputlisting[style=cpp]{src/uva10611-playboy-chimp/main.cpp}

\subsection{Algoritmos Gulosos}
\subsubsection{UVa 10340 - All in All}
Eu percorri a string `s' e a string `t' comparando os caracteres. Quando eles não são iguais, eu olho o próximo caractere de `t', até que eu finalmente encontre um que seja igual ao caractere de `s'. Quando os dois são iguais, eu pulo para o caracter seguinte de `s', e também de `t'. E quando eu chego ao final de `s', eu imprimo ``Yes''. Porém se o algoritmo não consegue chegar ao final da string `s', eu imprimo ``No''.
\lstinputlisting[style=cpp]{src/uva10340-all-in-all/main.cpp}

\subsection{Programação Dinâmica}
\subsubsection{UVa 10684 - The jackpot}
Eu li todos os valores da sequência para um ``array'' (\code{streak}). E então calculei todas as somas em um outro ``array'' (\code{results}). Então eu procurei a maior soma, que é o resultado. E se a maior soma for menor ou igual a zero, eu imprimo que não há sequência vencedora.
\lstinputlisting[style=cpp]{src/uva10684-the-jackpot/main.cpp}

TBD


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Grafos}

\subsection{Pesquisa em Grafos}
\subsubsection{UVa 10116 - Robot Motion}
Eu separei diferenças nas coordenadas para a movimentação com nomes mais comuns \code{Nth} (Norte), \code{Sth} (Sul), \code{Est} (Lest), \code{Wst} (Oeste). E então foi só seguir as direções conforme as ordens do input.
\lstinputlisting[style=cpp]{src/uva10116-robot-motion/main.cpp}

\subsection{Arvore Geradora Mínima}

\subsection{Caminho mais Curto de Origem Única}

\subsection{Caminho mais Curto de Todos os Pares}

\subsection{Fluxo em Rede}

\subsection{Grafos Especiais}

TBD


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Matemática}

\subsection{Combinatória}

\subsection{Teoria dos Números}

\subsection{Probabilidade}

\subsection{Identificação de Ciclos}

\subsection{Teoria dos Jogos}

TBD


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Processamento de Strings}

\subsection{Correspondência de String}

\subsection{Processamento de Strings com Programação Dinâmica}

\subsection{Suffix Trie/Tree/Array}

TBD


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Geometria Computacional}

\subsection{Objetos Geométricos Básicos com Bibliotecas}

\subsection{Algoritmos de Polígonos com Bibliotecas}

TBD


% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Tópicos mais Avançados}

\subsection{Técnicas mais Avançadas de Pesquisa}

\subsection{Técnicas mais Avançadas de Programação Dinâmica}

\subsection{Decomposição de Problemas}

TBD


\end{document}

%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "brasileiro"
%%% TeX-master: t
%%% End:
